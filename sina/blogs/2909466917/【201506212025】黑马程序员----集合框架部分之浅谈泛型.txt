原文链接：http://blog.sina.com.cn/s/blog_ad6af1250102vfmk.html
		
			
------Java培训、Android培训、iOS培训、.Net培训、期待与您交流！
-------

泛型：




概述：JDK1.5之后出现的新特性，用于解决安全问题，是一种类型安全机制；
语法：
ArrayList al=new
ArrayList();al.add("123");al.add(4);//编译时报错
Iterator
it=al.iterator();it.next().length();//不再需要进行强制转换
好处：
1.将本来在运行时报的错转移到了编译时，方便解决问题；
2.避免了强制转换的麻烦；
注意：

迭代器一样要加上，因为我们将元素取到迭代器中，因此要声明迭代器中的元素的类型，否则从
迭代器中取出的元素一样要强制转换才能使用；
使用：有的地方就是要定义泛型，通常用于集合框架；
所谓安全性问题：就是在使用多态特性时，例如我们参数使用Person类，但是方法中其实默认是要Dog类的，
但是我们传递Cat类也可以编译通过，但是运行时会报错，因为强转失败，除非提前使用instanceof来判
断；
当然不是说泛型可以代替原本多态的用法，多态的用法的优势在于一个方法可以操作多个子类对象，而这不是泛型出现的目的，泛型的优势在于当你只想操作一种对象时，使用泛型更安全；
泛型类：该类使用了泛型来作为类中不确定的引用数据类型的占位符；
用处：当类中引用数据类型不确定时：
早期使用Object提高程序扩展性，问题：1.需要转换，判断2.如果有错误，会在运行时期出现；
现在使用泛型类来解决，好处：1.不需要强转的麻烦和类型判断2.如果有错误，会在编译期间出现；

对比：类似于C++的模板类，不过不同于模板类的是泛型类需要在使用时中提供引用数据类型，且泛型无法
作用于基本数据类型，而模板类可以；
目的：1.提高程序扩展性。2.提高程序安全性。3.减少了强制转换，类型判断的麻烦，简化代码书写；
局限：一旦在定义类时指定了引用数据类型，那么就不能再操作别的类型了；
格式：class
Demo{.....}类中可以使用T作为一种类型使用，在创建对象时再明确T的类型。
泛型方法：

目的：让不同的方法操作不同的类型，将泛型定义在方法上；
语法：public void show(T
t){......}
优点：

1.使用该方法时不需要声明操作的引用数据类型，直接传入参数即可，jvm根据参数判断类型；

2.同一个方法可以多次操作不同的数据类型，不同于泛型类创建了对象，引用数据类型就固定了；
注意：在参数部分至少出现一次T，否则jvm无法判断T应该是什么类型，就无法调用响应的方法。
对比泛型类：

1.使用时不需要来指定引用数据类型，jvm自己根据参数判断；

2.更灵活，一个方法可以多次操作多个引用数据类型；

非常类似于C++的模板函数，不同的是泛型方法不接收基本数据类型，不过由于jdk1.5之后的自动装箱，因此也可以直接传递基本数据作为参数；
特例：静态方法不能使用类上定义的泛型，因为类上的泛型在建立对象时才确定类型，而静态方法随类加
载的，如果静态方法需要使用泛型时，可以使用泛型方法的方式；
格式：public static void show(W
w){......}
注意：泛型用于方法时，放在修饰符后，返回值前；
泛型接口：
两种方式：
1.类在实现接口时能够明确引用数据类型：class Demo
implements Inter{....}
2.类在实现接口时还不能确定引用数据类型：class
Demo implements Inter{.....}  
  
  
  在创建对象时再明确：Demo d = new
Demo();
用处：
泛型类：可以确定整个类中一次只操作一种引用数据类型，例如集合；
泛型方法：可能会对多个引用数据类型进行操作，要求更灵活的方式，例如一个比较大小的方法；
注意：在泛型类中一样可以定义泛型方法，jvm优先选取泛型方法，当一个方法为泛型时，它就不是随着定义类时提供的那个引用数据类型来固定参数了；

泛型高级应用：
？通配符，或者叫占位符；
用处：public void show(ArrayList